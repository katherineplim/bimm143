---
title: "Class 12: RNASeq Analysis"
author: "Katherine Lim (A15900881)"
format: pdf
---

Here we will use the DESeq2 package for RNASeq analysis. The data for today's class comes from a study of airway smooth muscle cells treated with dexamethasone, a synthetic glucocorticoid steroid with anti-inflammatory effects (Himes et al. 2014)

# Import the data

We need two things for this analysis:
- countData (counts for every transcript/gene in each experiment)
- metdata (metadata that describes the experimental setup)

```{r}
countData <- read.csv("airway_scaledcounts.csv", row.names = 1)
head(countData)
```

```{r}
metadata <- read.csv("airway_metadata.csv")
head(metadata)
```

> Q1. How many genes are in this dataset? 

```{r}
nrow(countData)
```

> Q2. How many ‘control’ cell lines do we have?

```{r}
sum(metadata$dex == "control")
```

Step 1.
- Calculate the mean of the control samples.

(a) We need to find which columns in countData are "control" samples.

```{r}
control.inds <- metadata$dex == "control"
```

(b) Extract all the control columns from  `countData` and call it `control.counts`.

```{r}
control.counts <- countData[, control.inds]
```

(c) Calculate the mean value across the rows of `control.counts` i.e. calculate the mean count values for each gene in the control samples.

```{r}
control.mean <- rowMeans(control.counts)
head(control.mean)
```

> Q3. How would you make the above code in either approach more robust?

You can use `rowMeans()` instead of `rowSum()`.

> Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

Step 2.
- Calculate the mean of the treated samples.

```{r}
# (a)
treated.inds <- metadata$dex == "treated"

# (b)
treated.counts <- countData[, treated.inds]

# (c)
treated.mean <- rowMeans(treated.counts)
head(treated.mean)
```

We now have control and treated mean count values. For ease of bookkeeping we can combine these vectors into a new data.frame called `meancounts`.

```{r}
meancounts <- data.frame(control.mean, treated.mean)
colSums(meancounts)
```

> Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples.

```{r}
plot(meancounts[, 1], meancounts[, 2], xlab = "Control", ylab = "Treated") 
```

We us log transforms for skewed data such as this because we really care most about relative changes in magnitude.

We most often use log2 as the math is easier to interpret than log10 or others.

If we have no change - i.e. same values in control and treated - then we will have a log2 value of zero.

```{r}
meancounts$log2fc <- log2(meancounts$treated.mean / meancounts$control.mean)
head(meancounts)
```

> Q5 (b).You could also use the ggplot2 package to make this figure. What geom_?() function would you use for this plot?

```{r}
library(ggplot2)

ggplot(meancounts) +
  aes(control.mean, treated.mean) +
  geom_point(alpha = 0.3)
```

> Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this?

```{r}
plot(meancounts[, 1], meancounts[, 2], xlab = "Control", ylab = "Treated", log = "xy") 
```

> Q. How many genes are up-regulated at the common threshold of +2 log2fc values?

```{r}
sum(meancounts$log2fc >= 2, na.rm = TRUE)
```

> Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

The arr.ind=TRUE argument will clause which() to return both the row and column indices (i.e. positions) where there are TRUE values. 

Calling unique() will ensure we dont count any row twice if it has zer entries in both samples. 

```{r}
zero.vals <- which(meancounts[, 1:2] == 0, arr.ind = TRUE)

to.rm <- unique(zero.vals[, 1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```

> Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level? 

```{r}
up.ind <- mycounts$log2fc > 2
sum(up.ind)
```

> Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level? 

```{r}
down.ind <- mycounts$log2fc < (-2)
sum(down.ind)
```

> Q10. Do you trust these results? Why or why not?

No, because we have not done anything to determine whether the differences we are seeing are significant so these results may be misleading.

# DESeq2 analysis

```{r}
library(DESeq2)
```

To use DESeq we need our input countData and colData in a specific formart that DESeq wants:

```{r}
dds <- DESeqDataSetFromMatrix(countData = countData, 
                       colData = metadata,
                       design = ~dex)
```

To run the analysis I can now use the main DESeq2 function called `DESeq()` with `dds` as an input.

```{r}
dds <-  DESeq(dds)
```

To get the results out of this `dds` object we can use the `results()` function from the package.

```{r}
res <- results(dds)
head(res)
```
Lrt's make a final plot of log2 fold-change vs. the adjusted P-value.

```{r}
plot(res$log2FoldChange, res$padj)
```

It is the low P-values that we care about and these are lost in the skewed plot above. Let's take the log of the `$padj` values for our plot.

```{r}
plot(res$log2FoldChange, -log(res$padj))
abline(v = c(+2, -2), col = "gray")
abline(h = -log(0.05), col = "gray")
```

Finally we can make a color vector to use in the plot to better highlight the genes we care about.

```{r}
mycols <- rep("gray", nrow(res))
mycols[abs(res$log2FoldChange) >= 2] <- "red"
mycols[res$padj > 0.05] <-"gray"
  
plot(res$log2FoldChange, -log(res$padj), col = mycols)
abline(v = c(+2, -2), col = "blue")
abline(h = -log(0.05), col = "blue")
```

---

# Add annotation datas

We can use `AnnotationDbi` package to add annotation daata such as gene identifiers from different sources to our results object.

```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```

We can translate between these database ID formats.

```{r}
columns(org.Hs.eg.db)
```

My IDs are stored as the rownames of `res`

```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys = row.names(res), 
                     keytype = "ENSEMBL", 
                     column = "SYMBOL", 
                     multiVals = "first")

res$entrez <- mapIds(org.Hs.eg.db,
                     keys = row.names(res), 
                     keytype = "ENSEMBL", 
                     column = "ENTREZID", 
                     multiVals = "first")

res$genename <- mapIds(org.Hs.eg.db,
                     keys = row.names(res), 
                     keytype = "ENSEMBL", 
                     column = "GENENAME", 
                     multiVals = "first")
```

```{r}
head(res)
```

# Save our results

```{r}
write.csv(res, file = "myresults.csv")
```

# Pathway analysis

WE can use the KEFF database of biological pathways to get some more insight into our differentially expressed genes and the kinds of biology they are involved in.

```{r}
library(pathview)
library(gage)
library(gageData)
```

Look at the first two KEGG pathways.

```{r}
data(kegg.sets.hs)
head(kegg.sets.hs, 2)
```

Make a new vector of fold-change values that I will use as input for `gage` which will have the ENTREZ IDs as names.

```{r}
foldchanges = res$log2FoldChange
names(foldchanges) = res$entrez
head(foldchanges)
```

```{r}
keggres = gage(foldchanges, gsets = kegg.sets.hs)
```

Look at the top 3 "LESS"

```{r}
head(keggres$less, 3)
```

Now I can use the KEGG IDs of these pathways from gage to view our genes mapped on these pathways. 

```{r}
pathview(gene.data = foldchanges, pathway.id = "hsa05310")
```

![Asthma pathway from KEGG with our genes shown in color](hsa05310.pathview.png)





